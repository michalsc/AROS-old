<HTML
><HEAD
><TITLE
>Usage of Libraries</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.42"><LINK
REL="HOME"
TITLE="The Amiga Research OS"
HREF="book1.html"><LINK
REL="UP"
TITLE="Libraries and Taglists"
HREF="chap-libraries.html"><LINK
REL="PREVIOUS"
TITLE="Libraries and Taglists"
HREF="chap-libraries.html"><LINK
REL="NEXT"
TITLE="Giving Additional Arguments with Taglists"
HREF="sect-taglists.html"></HEAD
><BODY
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
><SPAN
CLASS="PRODUCTNAME"
>The Amiga Research OS</SPAN
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="chap-libraries.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 2. Libraries and Taglists</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="sect-taglists.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN218"
>Usage of Libraries</A
></H1
><P
>To use the functions of a library, you have to open the library
        first. The only library that doesn't have to be opened first is
        <TT
CLASS="FILENAME"
>exec.library</TT
>. Exec is always open and your compiler
        knows how to access it. Your compiler may addtionally open some
        libraries for you, so you don't have to open them manually. Read your
        compiler's manual to learn about such features.</P
><P
>To open a library you have to use a function of
        <TT
CLASS="FILENAME"
>exec.library</TT
>:
        <DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;proto/exec.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>struct Library * <B
CLASS="FSFUNC"
>OpenLibrary</B
></CODE
>(STRPTR <VAR
CLASS="PDPARAM"
>name</VAR
>, ULONG <VAR
CLASS="PDPARAM"
>version</VAR
>);</CODE
></P
><P
></P
></DIV
></P
><P
><TT
CLASS="FUNCTION"
>OpenLibrary()</TT
> takes two arguments:
        <P
></P
><UL
><LI
><P
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
> points to the name of
          the library. Normally this is just the plain name, but this can
          also be a complete (absolute or relative) path to the library.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>Paths do not work with kernel-based libraries
          (<SPAN
CLASS="ABBREV"
>ie</SPAN
> libraries that are included in the kernel).
          Use absolute path only, if you know exactly, what you are doing!
          </P
></BLOCKQUOTE
></DIV
></LI
><LI
><P
><TT
CLASS="PARAMETER"
><I
>version</I
></TT
> is the minimal
          version of the library to open. If the named library is found, but
          its version is lower than <TT
CLASS="PARAMETER"
><I
>version</I
></TT
>, the
          library will not be opened, but an error will be returned. Versions
          are important, because libraries are supposed to be expandable. Some
          functions are only available from a certain version of a library on.
          For example the function <TT
CLASS="FUNCTION"
><A
HREF="exec-allocvec.html"
>AllocVec()</A
></TT
>
          of <TT
CLASS="FILENAME"
>exec.library</TT
> was introduced in version 36
          of the library. If you try to call this function with lower versions
          of <TT
CLASS="FILENAME"
>exec.library</TT
> installed, unexpected things
          will happen (most likely the application will crash).</P
></LI
></UL
></P
><DIV
CLASS="PROCEDURE"
><P
>The following procedure is used to load the library to open:</P
><OL
TYPE="1"
><LI
><P
>First, the name of the library is searched for in the
            list of already loaded libraries (<I
CLASS="GLOSSTERM"
><I
CLASS="FIRSTTERM"
>resident
            list</I
></I
>). If this library
            was loaded into memory before (eg by a different program) and still
            is there, everything is fine and <TT
CLASS="FUNCTION"
>OpenLibrary()</TT
>
            returns now.</P
><P
>Libraries in the kernel are always on list of loaded libraries.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>Comparisons in this list are case sensitive! Be sure
            to use the right case in <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>. Normally
            all characters in a library name are lower-case.</P
></BLOCKQUOTE
></DIV
></LI
><LI
><P
>If the library was not found in the resident list and
            a path was supplied with <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>, the given
            file is tried to be opened. If this fails,
            <TT
CLASS="FUNCTION"
>OpenLibrary()</TT
> returns an error.
          </P
></LI
><LI
><P
>If only the plain library-name was given, the library is
            searched for in the <I
CLASS="GLOSSTERM"
>current directory</I
>
            first. If it's not found there, it is searched for in the
            directory <TT
CLASS="FILENAME"
>LIBS:</TT
>.
          </P
></LI
></OL
></DIV
><P
><TT
CLASS="FUNCTION"
>OpenLibrary()</TT
> returns either a pointer to
        a structure, describing the library (<A
HREF="exec-libraries-h.html#EXEC-LIBRARIES-LIBRARY"
>struct <SPAN
CLASS="STRUCTNAME"
>Library *</SPAN
></A
>
        defined in <TT
CLASS="FILENAME"
>exec/libraries.h</TT
>)
        or <SPAN
CLASS="SYMBOL"
>NULL</SPAN
>, meaning that opening the library failed for
        some reason. The resulting pointer has to be stored for the compiler's
        use. Normally it is stored in a variable in the form:
        <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>Libname</I
></TT
>Base</TT
>, eg
        <TT
CLASS="LITERAL"
>IntuitionBase</TT
> for the pointer to
        <TT
CLASS="FILENAME"
>intuition.library</TT
>.</P
><P
>After opening the library, you can use its functions by just
        calling them like any other function in your program. But to let your
        compiler know, what to do, you have to include the
        library-specific header-file. This is normally called
        <TT
CLASS="FILENAME"
>proto/<TT
CLASS="REPLACEABLE"
><I
>libname</I
></TT
>.h</TT
> for
        C compilers.</P
><P
>When you have finished using the library you have to close it
        again to free the resources used by it. This is performed with:
        <DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;proto/exec.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>CloseLibrary</B
></CODE
>(struct Library * <VAR
CLASS="PDPARAM"
>libbase</VAR
>);</CODE
></P
><P
></P
></DIV
></P
><P
><TT
CLASS="FUNCTION"
>CloseLibrary()</TT
> closes the library pointed
        to by <TT
CLASS="PARAMETER"
><I
>libbase</I
></TT
>. This may also be
        <SPAN
CLASS="SYMBOL"
>NULL</SPAN
>, in which case <TT
CLASS="FUNCTION"
>CloseLibrary()</TT
>
        does nothing.</P
><P
>We will demonstrate the use of libraries by creating a small
        graphical hello-world program. Instead of printing <TT
CLASS="COMPUTEROUTPUT"
>Hello World!</TT
> to
        the console, we will display it in a requester. A function to display
        a requester is <TT
CLASS="FUNCTION"
><A
HREF="intuition-easyrequestargsa.html"
>EasyRequestArgs()</A
></TT
>,
        being a function of <TT
CLASS="FILENAME"
>intuition.library</TT
>.
        We will not discuss its usage here. For more information, see the
        section about <A
HREF="chap-requesters.html"
>Requesters</A
>.</P
><DIV
CLASS="EXAMPLE"
><P
><B
>Example 2-1. Usage of libraries</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#include &#60;proto/exec.h&#62;          /* OpenLibrary() and CloseLibrary() */
#include &#60;exec/libraries.h&#62;      /* struct Library */
#include &#60;dos/dos.h&#62;             /* RETURN_OK and RETURN_FAIL */
#include &#60;proto/intuition.h&#62;     /* EasyRequestArgs() */
#include &#60;intuition/intuition.h&#62; /* struct EasyStruct */

/* This variable will store the pointer to intuition.library */
struct Library *IntuitionBase;

int main(int argc, char *argv[])
{
    /* Needed for EasyRequestArgs(). Just ignore. */
    struct EasyStruct es = {
      sizeof(struct EasyStruct), 0UL,
      "Requester", "Hello World!", "Ok"
    };

    /* First, we open intuition.library. We need version 36 or better,
       because EasyRequestArgs() was introduced in that version of
       intuition.library.
    */
    IntuitionBase = OpenLibrary("intuition.library", 36);

    /* We have to check, if intuition.library was successfully opened.
       If it was not, we must not call a function from it, so we return
       immediatly with an error.
    */
    if (!IntuitionBase)
        return RETURN_FAIL;

    /* After opening intuition.library, we can call EasyRequestArgs(). */
    EasyRequestArgs(NULL, &#38;es, NULL, NULL);

    /* At last, we have to close intuition.library again. */
    CloseLibrary(IntuitionBase);

    return RETURN_OK;
}
          </PRE
></TD
></TR
></TABLE
></DIV
><P
>Try to compile and run this program. It should present you a
        handsome hello-world requester.</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="chap-libraries.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sect-taglists.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Libraries and Taglists</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="chap-libraries.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Giving Additional Arguments with Taglists</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>