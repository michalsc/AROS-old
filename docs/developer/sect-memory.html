<HTML
><HEAD
><TITLE
>Memory Handling</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.42"><LINK
REL="HOME"
TITLE="The Amiga Research OS"
HREF="book1.html"><LINK
REL="UP"
TITLE="Exec Lists and Memory Management"
HREF="chap-memory.html"><LINK
REL="PREVIOUS"
TITLE="Exec Lists and Memory Management"
HREF="chap-memory.html"><LINK
REL="NEXT"
TITLE="Files and Directories"
HREF="chap-files.html"></HEAD
><BODY
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
><SPAN
CLASS="PRODUCTNAME"
>The Amiga Research OS</SPAN
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="chap-memory.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 3. Exec Lists and Memory Management</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="chap-files.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="SECT-MEMORY"
>Memory Handling</A
></H1
><P
>You need memory for nearly everything in a program. Many things
        can be done by using the stack. But often you need larger chunks of
        memory or don't want to use the stack for some reason. In these cases
        you have to allocate memory by yourself.</P
><P
><TT
CLASS="FILENAME"
>exec.library</TT
> provides different methods for
        allocating memory. The two most important functions are
        <DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;proto/exec.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>APTR <B
CLASS="FSFUNC"
>AllocMem</B
></CODE
>(ULONG <VAR
CLASS="PDPARAM"
>size</VAR
>, ULONG <VAR
CLASS="PDPARAM"
>flags</VAR
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>APTR <B
CLASS="FSFUNC"
>AllocVec</B
></CODE
>(ULONG <VAR
CLASS="PDPARAM"
>size</VAR
>, ULONG <VAR
CLASS="PDPARAM"
>flags</VAR
>);</CODE
></P
><P
></P
></DIV
>
        Both functions return a pointer to a memory area of the requested
        <TT
CLASS="PARAMETER"
><I
>size</I
></TT
> provided as argument. If not enough memory
        was available, <SPAN
CLASS="SYMBOL"
>NULL</SPAN
> is returned, instead. You must check
        for this condition, before using the memory. If the memory was
        successfully allocated, you can do with it whatever you want to.</P
><P
>You can provide additional <TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> to get a
        special kind of memory. The following flags are defined in
        <A
HREF="exec-memory-h.html"
><TT
CLASS="FILENAME"
>exec/memory.h</TT
></A
>:
        <P
></P
><DL
><DT
><SPAN
CLASS="SYMBOL"
>MEMF_CLEAR</SPAN
></DT
><DD
><P
>The allocated memory area is initialized with zeros.</P
></DD
><DT
><SPAN
CLASS="SYMBOL"
>MEMF_LOCAL</SPAN
></DT
><DD
><P
>Get memory that will not be flushed, if the computer
            is reset.</P
></DD
><DT
><SPAN
CLASS="SYMBOL"
>MEMF_CHIP</SPAN
></DT
><DD
><P
>Get memory that is accessible by graphics and
            sound chips. This type of memory is required for some functions.
            </P
></DD
><DT
><SPAN
CLASS="SYMBOL"
>MEMF_FAST</SPAN
></DT
><DD
><P
>Get memory that is not accessible by graphics and
            sound chips. <I
CLASS="EMPHASIS"
>You should normally not set this
            flag! It is needed only for some very esoteric functions. Many
            systems don't have this kind of memory.</I
></P
></DD
><DT
><SPAN
CLASS="SYMBOL"
>MEMF_PUBLIC</SPAN
></DT
><DD
><P
>This flag must be set, if the memory you allocate
            is to be accessible by other tasks. If you do not set it, the
            allocated memory is <I
CLASS="EMPHASIS"
>private</I
> to your task. This
            issue will be discussed in detail in the chapter about
            <A
HREF="x1278.html#AEN1278"
>inter-task communication</A
>.</P
></DD
><DT
><SPAN
CLASS="SYMBOL"
>MEMF_REVERSE</SPAN
></DT
><DD
><P
>If this flag is set, the order of the search for
            empty memory blocks is reversed. Blocks that are at the end of the
            list of empty memory will be found first.</P
></DD
><DT
><SPAN
CLASS="SYMBOL"
>MEMF_NO_EXPUNGE</SPAN
></DT
><DD
><P
>Normally, if not enough free memory of the requested
            size is found, <SPAN
CLASS="ACRONYM"
>AROS</SPAN
> tries to free
            unused memory, for example by flushing unused libraries out of the
            memory. If this flag is set, this behaviour is turned off.</P
></DD
></DL
></P
><P
>Memory allocated with these functions <I
CLASS="EMPHASIS"
>must be freed</I
>
        after use with one of the following functions. <I
CLASS="EMPHASIS"
>Note well that
        you must not use memory that was already freed.</I
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;proto/exec.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>FreeMem</B
></CODE
>(APTR <VAR
CLASS="PDPARAM"
>memory</VAR
>, ULONG <VAR
CLASS="PDPARAM"
>size</VAR
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>FreeVec</B
></CODE
>(APTR <VAR
CLASS="PDPARAM"
>memory</VAR
>, ULONG <VAR
CLASS="PDPARAM"
>size</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Of course, <TT
CLASS="FUNCTION"
>FreeMem()</TT
> must be used for memory
        allocated with <TT
CLASS="FUNCTION"
>AllocMem()</TT
> and
        <TT
CLASS="FUNCTION"
>FreeVec()</TT
> for memory allocated with
        <TT
CLASS="FUNCTION"
>AllocVec()</TT
>. The synopsis for these two functions
        shows the difference between <TT
CLASS="FUNCTION"
>AllocMem()</TT
> and
        <TT
CLASS="FUNCTION"
>AllocVec()</TT
>: <TT
CLASS="FUNCTION"
>AllocVec()</TT
>
        remembers the size of the chunk of memory, it allocated. So, if you
        use <TT
CLASS="FUNCTION"
>AllocVec()</TT
>, you don't have to store the
        requested size, while you have to, if you use
        <TT
CLASS="FUNCTION"
>AllocMem()</TT
>.


        <DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN710"
>Allocating Multiple Regions of Memory at once</A
></H2
><P
>Sometimes you may want to make multiple memory allocations at
          once. The usual way to do this is calling <TT
CLASS="FUNCTION"
>AllocVec()</TT
>
          with the size of all memory-blocks added and then making pointers
          relative to the returned pointer. But what do you do, if you need
          memory of different kinds, it with different <SPAN
CLASS="SYMBOL"
>MEMF_</SPAN
>
          flags set? You could make multiple allocations or simply use the
          function
          <DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;proto/exec.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>struct MemList * <B
CLASS="FSFUNC"
>AllocEntry</B
></CODE
>(struct MemList * <VAR
CLASS="PDPARAM"
>oldlist</VAR
>);</CODE
></P
><P
></P
></DIV
></P
><P
>As you will have noticed, <TT
CLASS="FUNCTION"
>AllocEntry</TT
> uses
          a pointer to a <A
HREF="exec-memory-h.html#EXEC-MEMORY-MEMLIST"
>struct <SPAN
CLASS="STRUCTNAME"
>MemList</SPAN
></A
>
          as only argument and as result. We find the definition of this
          structure in <A
HREF="exec-memory-h.html"
><TT
CLASS="FILENAME"
>exec/memory.h</TT
></A
>:
          <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct MemEntry
{
    union
    {
        ULONG meu_Reqs;
        APTR  meu_Addr;
    } me_Un;
    ULONG me_Length;
};
 

struct MemList
{
    struct Node     ml_Node;
    UWORD           ml_NumEntries;
    struct MemEntry ml_ME[1];
};
          </PRE
></TD
></TR
></TABLE
>
          The array <TT
CLASS="STRUCTFIELD"
><I
>ml_ME</I
></TT
> of <SPAN
CLASS="STRUCTNAME"
>struct
          MemList</SPAN
> has a variable number of elements. The number
          of its elements is set in <TT
CLASS="STRUCTFIELD"
><I
>ml_NumEntries</I
></TT
>.</P
><P
>The struct <SPAN
CLASS="STRUCTNAME"
>MemEntry</SPAN
> describes one
          memory-entry. Stored are its size (<TT
CLASS="STRUCTFIELD"
><I
>me_Length</I
></TT
>),
          its requirements (ie the <A
HREF="sect-memory.html#EXPL-MEMF"
><SPAN
CLASS="SYMBOL"
>MEMF_</SPAN
>
          flags</A
>, set in <TT
CLASS="STRUCTFIELD"
><I
>me_Un.meu_Reqs</I
></TT
>) and
          possibly a pointer to the memory-block (<TT
CLASS="STRUCTFIELD"
><I
>me_Un.meu_Addr</I
></TT
>).</P
><P
>The struct <SPAN
CLASS="STRUCTNAME"
>MemList</SPAN
>, you pass in as
          <TT
CLASS="PARAMETER"
><I
>oldlist</I
></TT
>, must have set the field
          <TT
CLASS="STRUCTFIELD"
><I
>ml_NumEntries</I
></TT
> to the actual number of
          struct <SPAN
CLASS="STRUCTNAME"
>MemEntry</SPAN
>s contained in
          <TT
CLASS="STRUCTFIELD"
><I
>ml_ME</I
></TT
>. The <SPAN
CLASS="STRUCTNAME"
>struct
          MemEntry</SPAN
>s must have set the fields
          <TT
CLASS="STRUCTFIELD"
><I
>me_Length</I
></TT
> and
          <TT
CLASS="STRUCTFIELD"
><I
>me_Un.meu_Reqs</I
></TT
>. The other fields are
          ignored.</P
><P
>The function returns a pointer to a copy of the
          struct <SPAN
CLASS="STRUCTNAME"
>MemEntry</SPAN
>, passed in as
          <TT
CLASS="PARAMETER"
><I
>oldlist</I
></TT
>, with all the relevant fields set
          (especially <TT
CLASS="STRUCTFIELD"
><I
>me_Un.meu_Addr</I
></TT
>). An error is
          indicated by setting the most significant bit of the pointer
          returned. So you always have to check it, before using the pointer
          returned.</P
><P
>Memory allocated with <TT
CLASS="FUNCTION"
>AllocEntry()</TT
> must
          be freed using <TT
CLASS="FUNCTION"
>FreeMem()</TT
>.
        </P
></DIV
>


        <DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN755"
>Memory Pools</A
></H2
><P
><SPAN
CLASS="ACRONYM"
>AROS</SPAN
> manages different
          so-called memory-pools. Each memory-pool contains a list of
          memory-areas. The most important memory-pool is the pool that
          contains all free memory in the system. But you also can create
          memory-pools yourself. This has some advantages:

          <P
></P
><UL
><LI
><P
>Everytime, you allocate some memory, the memory
            in the system becomes more fragmented. This fragmentation causes
            the available memory chunks to become smaller. This way larger
            allocations will fail. To prevent this problem, memory-pools were
            introduced. Instead of allocating many small chunks of memory,
            the pool-management routines allocate large chunks and then
            return small chunks out of it, when memory-requests are made.</P
></LI
><LI
><P
>Private memory-pools have the ability to keep
            track of all the allocations you made so that all memory in a
            pool can be freed with one simple function-call (but you can also
            free memory individually).<P
></P
></P
></LI
></UL
></P
><P
>Before a memory-pool can be used, it must be created. This is
          performed by the function
          <DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;proto/exec.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>APTR <B
CLASS="FSFUNC"
>CreatePool</B
></CODE
>(ULONG <VAR
CLASS="PDPARAM"
>flags</VAR
>, ULONG <VAR
CLASS="PDPARAM"
>puddleSize</VAR
>, ULONG <VAR
CLASS="PDPARAM"
>threshSize</VAR
>);</CODE
></P
><P
></P
></DIV
>
          <TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> specifies the type of memory you want
          to get from the <TT
CLASS="FUNCTION"
>AllocPooled()</TT
> function
          (<A
HREF="sect-memory.html#EXPL-ALLOCPOOLED"
>see below</A
>). All
          <SPAN
CLASS="SYMBOL"
>MEMF_</SPAN
> definitions as <A
HREF="sect-memory.html#EXPL-MEMF"
>described
          above</A
> are allowed here.</P
><P
><TT
CLASS="PARAMETER"
><I
>puddleSize</I
></TT
> is the size of the chunks
          of memory that are allocated by the pool functions. Usually a size
          about ten times bigger than the average memory-size, you need to
          allocate, is a good guess. But on the other hand the
          <TT
CLASS="PARAMETER"
><I
>puddleSize</I
></TT
> should not be too large. Normally
          you should limit it to about <TT
CLASS="LITERAL"
>50kb</TT
>. Note well,
          though, that these are only suggestions and no real limitations.</P
><P
>Finally, the <TT
CLASS="PARAMETER"
><I
>threshSize</I
></TT
> specifies,
          how large the memory that is to be allocated is allowed to be so
          that no new chunk is allocated automatically. If, for example,
          the <TT
CLASS="PARAMETER"
><I
>threshSize</I
></TT
> is set to 25kb and you want
          to allocate a piece of memory with the size of 30kb, the internal
          lists of chunks of that memory-pool is not searched, but the memory
          is allocated directly, instead. If the memory to be allocated
          was only 20kb, the chunk-list would have been searched for a piece
          of free memory of that size, first. Of course, the
          <TT
CLASS="PARAMETER"
><I
>threshSize</I
></TT
> <I
CLASS="EMPHASIS"
>must not</I
> be
          larger than the <TT
CLASS="PARAMETER"
><I
>puddleSize</I
></TT
> and should not
          be too small, either. Half the <TT
CLASS="PARAMETER"
><I
>puddleSize</I
></TT
> is
          a good guess here.</P
><P
><TT
CLASS="FUNCTION"
>CreatePool()</TT
> returns a private pointer to
          a pool-structure that must be saved for further use.
          <SPAN
CLASS="SYMBOL"
>NULL</SPAN
> is returned, if no memory for the
          pool-structure was available. You have to check for this condition.</P
><P
>After use, all memory-pools must be destroyed by calling
          <DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;proto/exec.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>DeletePool</B
></CODE
>(APTR <VAR
CLASS="PDPARAM"
>pool</VAR
>);</CODE
></P
><P
></P
></DIV
>
          This function deletes the <TT
CLASS="PARAMETER"
><I
>pool</I
></TT
> passed in.
          Additionally all memory that was allocated in this pool is freed.
          This way, you don't need to remember every single piece of memory,
          you allocated in a pool. Just call <TT
CLASS="FUNCTION"
>DeletePool()</TT
>
          at the end. Note that you should be careful not to use pooled memory
          after its pool was deleted!</P
><P
>If you want to allocate memory out of a
          pool, you need to call
          <DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;proto/exec.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void * <B
CLASS="FSFUNC"
>AllocPooled</B
></CODE
>(APTR <VAR
CLASS="PDPARAM"
>pool</VAR
>, ULONG <VAR
CLASS="PDPARAM"
>size</VAR
>);</CODE
></P
><P
></P
></DIV
>
          Besides the <TT
CLASS="PARAMETER"
><I
>pool</I
></TT
> to allocate memory from,
          the <TT
CLASS="PARAMETER"
><I
>size</I
></TT
> of the memory to allocate must be
          passed in. Returned is a pointer to a block of memory of the
          requested size or <SPAN
CLASS="SYMBOL"
>NULL</SPAN
> to indicate that not
          enough memory was available.</P
><P
>Memory allocated with <TT
CLASS="FUNCTION"
>AllocPooled()</TT
> can
          be freed by either destroying the whole pool with
          <TT
CLASS="FUNCTION"
>DeletePool()</TT
> or individually by calling
          <DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;proto/exec.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>FreePooled</B
></CODE
>(APTR <VAR
CLASS="PDPARAM"
>pool</VAR
>, void * <VAR
CLASS="PDPARAM"
>memory</VAR
>, ULONG <VAR
CLASS="PDPARAM"
>size</VAR
>);</CODE
></P
><P
></P
></DIV
>
          This function frees exactly one piece of memory that was previously
          allocated with <TT
CLASS="FUNCTION"
>AllocPooled()</TT
>. The pointer to
          the <TT
CLASS="PARAMETER"
><I
>memory</I
></TT
> pointer, returned by
          <TT
CLASS="FUNCTION"
>AllocPooled()</TT
>, its <TT
CLASS="PARAMETER"
><I
>size</I
></TT
>
          and the pool, it is in, have to be supplied as arguments.

          <TABLE
CLASS="SIDEBAR"
BORDER="1"
CELLPADDING="5"
><TR
><TD
><DIV
CLASS="SIDEBAR"
><P
><B
><TT
CLASS="FUNCTION"
>DeletePool()</TT
> vs <TT
CLASS="FUNCTION"
>FreePooled()</TT
></B
></P
><P
>You may ask yourself: "If <TT
CLASS="FUNCTION"
>DeletePool()</TT
>
            deletes all the memory of a pool, why should I ever use
            <TT
CLASS="FUNCTION"
>FreePooled()</TT
>?" The answer is easy: to
            save memory. Normally it's good style to free memory as soon as
            you don't need it anymore. But sometimes it is easier just to
            free a memory-pool after a bunch of allocations. Nevertheless
            you should not use this feature, if you are not sure, when the
            memory-pool will be deleted. Imagine a program like this (do not
            try to compile it; it won't):</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#define &#60;exec/types.h&#62;
#define &#60;exec/memory.h&#62;
#define &#60;dos/dos.h&#62;

int main(int argc, char *argv[])
{
    APTR pool;
    APTR mem;

    /* Create our memory pool and test, if it was successful. */
    pool = CreatePool(MEMF_ANY, 50*1024, 25*1024);
    if (pool)
    {

        /* Just a dummy function. Image that this function will open a window,
           with two buttons "Do Action" and "Quit".
        */
        open_our_window();

        for(;;)
        {
            /* Another dummy function that returns one of the definitions
               below.
            */
            switch(get_action())
            {
            /* This is returned, if the button "Do Action" was released. */
            case DOACTION:
                mem = AllocPooled(pool, 10*1024);
                if (mem)
                {
                    /* Another dummy function that uses our memory. */
                    silly_function(mem);
                }
                break;
            /* This is returned, if the button "Quit" was released. */
            case QUIT:
                return RETURN_OK;
            }
        }

        /* Close the window, we have opened above. */
        close_our_window();

        /* Delete our pool. */
        DeletePool(pool);
    }
}
            </PRE
></TD
></TR
></TABLE
><P
>Each time the button <SPAN
CLASS="GUIBUTTON"
>Do Action</SPAN
> is
            released, some memory is allocated. This memory is freed at the
            end of the program, when <TT
CLASS="FUNCTION"
>DeletePool()</TT
> is
            called. Of course, the longer the program is used, the more
            memory will be in use. That is why it would be much better to
            free the memory after use. This is done by replacing the
            part between <TT
CLASS="LITERAL"
>case DOACTION:</TT
> and
            <TT
CLASS="LITERAL"
>case QUIT:</TT
> by:
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>                mem = AllocPooled(pool, 10*1024);
                if (mem)
                {
                    silly_function(mem);
                    FreePooled(pool, mem, 10*1024);
                }
                break;
            </PRE
></TD
></TR
></TABLE
>
          </P
></DIV
></TD
></TR
></TABLE
>

          <DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN852"
>Obsolete Memory Pool Functions</A
></H3
><P
>Memory-pools are managed with <A
HREF="exec-memory-h.html#EXEC-MEMORY-MEMHEADER"
>struct <SPAN
CLASS="STRUCTNAME"
>MemHeader</SPAN
></A
>s.
            If you have a pointer to such a structure, you may try to
            allocate some memory of its pool:
            <DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;proto/exec.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void * <B
CLASS="FSFUNC"
>Allocate</B
></CODE
>(struct MemHeader * <VAR
CLASS="PDPARAM"
>mh</VAR
>, ULONG <VAR
CLASS="PDPARAM"
>size</VAR
>);</CODE
></P
><P
></P
></DIV
>
            Apart from the pointer to the struct <SPAN
CLASS="STRUCTNAME"
>MemHeader</SPAN
>
            passed in as <TT
CLASS="PARAMETER"
><I
>mh</I
></TT
>, you have to supply the
            <TT
CLASS="PARAMETER"
><I
>size</I
></TT
> of the memory-block you want to
            allocate. This function returns either a pointer to the first
            memory-block found or <SPAN
CLASS="SYMBOL"
>NULL</SPAN
> if no matching block
            was found.</P
><P
>You must free every memory-block allocated with
            <TT
CLASS="FUNCTION"
>Allocate()</TT
> with
            <DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;proto/exec.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>Deallocate</B
></CODE
>(struct MemHeader * <VAR
CLASS="PDPARAM"
>mh</VAR
>, APTR <VAR
CLASS="PDPARAM"
>mem</VAR
>, ULONG <VAR
CLASS="PDPARAM"
>size</VAR
>);</CODE
></P
><P
></P
></DIV
>
            You have to pass the same <TT
CLASS="PARAMETER"
><I
>mh</I
></TT
> and
            <TT
CLASS="PARAMETER"
><I
>size</I
></TT
> to <TT
CLASS="FUNCTION"
>Deallocate()</TT
>
            as you have passed to <TT
CLASS="FUNCTION"
>Allocate()</TT
> and
            additionally the pointer returned by it.</P
><P
><TT
CLASS="FILENAME"
>intuition.library</TT
>
            provides another way to handle memory pools with the functions
            <A
HREF="intuition-allocremember.html"
><TT
CLASS="FUNCTION"
>AllocRemember()</TT
></A
>
            and <A
HREF="intuition-freeremember.html"
><TT
CLASS="FUNCTION"
>FreeRemember()</TT
></A
>.
            Note, though, that these are obsolete. You should use the normal
            pool-functions of <TT
CLASS="FILENAME"
>exec.library</TT
>,
            instead.</P
></DIV
>
        </P
></DIV
>


        <DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN894"
>Allocating a specific memory address</A
></H2
><P
>Under very rare circumstances you may have to allocate
          memory at a specific memory address. This performed by using
          <DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;proto/exec.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void * <B
CLASS="FSFUNC"
>AllocAbs</B
></CODE
>(ULONG <VAR
CLASS="PDPARAM"
>size</VAR
>, APTR <VAR
CLASS="PDPARAM"
>address</VAR
>);</CODE
></P
><P
></P
></DIV
>
          This function tries to allocate <TT
CLASS="PARAMETER"
><I
>size</I
></TT
> bytes at
          <TT
CLASS="PARAMETER"
><I
>address</I
></TT
>. If this is successful, a pointer
          to the requested address is returned. If some memory of the
          requested block is already allocated or is not available in the
          system, <SPAN
CLASS="SYMBOL"
>NULL</SPAN
> is returned, instead.</P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Warning</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>The beginning of the memory block requested will
          be used by exec to store its node-data (the exact size is calculated
          by (2*sizeof (void *)) ). Therefore, you <I
CLASS="EMPHASIS"
>must not
          write</I
> to the beginning of the memory-block! Because of
          these obstacles you should not use <TT
CLASS="FUNCTION"
>AllocAbs()</TT
>,
          except if you really need it.</P
></TD
></TR
></TABLE
></DIV
><P
>Memory allocated with <TT
CLASS="FUNCTION"
>AllocAbs()</TT
> must
          be freed, using <TT
CLASS="FUNCTION"
>FreeMem()</TT
>.
        </P
></DIV
>

        <DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN916"
>Querying Memory Size and Available Memory</A
></H2
><P
>To get the size of available memory, use the function
          <DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;proto/exec.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ULONG <B
CLASS="FSFUNC"
>AvailMem</B
></CODE
>(ULONG <VAR
CLASS="PDPARAM"
>type</VAR
>);</CODE
></P
><P
></P
></DIV
></P
><P
><TT
CLASS="PARAMETER"
><I
>type</I
></TT
> are some of the following flags (or'ed),
          as defined in <A
HREF="exec-memory-h.html"
><TT
CLASS="FILENAME"
>exec/memory.h</TT
></A
>:
          <P
></P
><DL
><DT
><SPAN
CLASS="SYMBOL"
>MEMF_ANY</SPAN
></DT
><DD
><P
>Return the size of all free memory in the system.</P
></DD
><DT
><SPAN
CLASS="SYMBOL"
>MEMF_CHIP</SPAN
></DT
><DD
><P
>Return the size of memory, which is accessible
              by graphics and sound chips.</P
></DD
><DT
><SPAN
CLASS="SYMBOL"
>MEMF_FAST</SPAN
></DT
><DD
><P
>Return the size of memory that is not accessible
              by graphics and sound chips.</P
></DD
><DT
><SPAN
CLASS="SYMBOL"
>MEMF_LARGEST</SPAN
></DT
><DD
><P
>Return only the largest block, instead of all
              memory of the type specified.</P
></DD
></DL
>
          You may as well specify other <SPAN
CLASS="SYMBOL"
>MEMF_</SPAN
> flags,
          they will be simply ignored.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>Note well that the queried memory-size does not have to
          reflect the real size of memory available, as this may always
          change in a multitasking-system, even while <TT
CLASS="FUNCTION"
>AvailMem()</TT
>
          is executed.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="EXAMPLE"
><P
><B
>Example 3-2. Program to list memory available in the system</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#include &#60;stdio.h&#62;
#include &#60;exec/memory.h&#62;

int main(int argc, char *argv[])
{
    printf("Total free memory: %h, largest block: %h\n",
      AvailMem(MEMF_ANY), AvailMem(MEMF_ANY|MEMF_LARGEST));
    printf("Free chip memory:  %h, largest block: %h\n",
      AvailMem(MEMF_CHIP), AvailMem(MEMF_CHIP|MEMF_LARGEST));
    printf("Free fast memory:  %h, largest block: %h\n",
      AvailMem(MEMF_FAST), AvailMem(MEMF_FAST|MEMF_LARGEST));
}
            </PRE
></TD
></TR
></TABLE
></DIV
></DIV
>


        <DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN958"
>Adding Memory to the System</A
></H2
><P
>This chapter is only of concern to you, if you want to write a
          hardware-driver for a piece of hardware, which adds memory to the
          system.</P
><P
>          <DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;proto/exec.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>AddMemList</B
></CODE
>(ULONG <VAR
CLASS="PDPARAM"
>size</VAR
>, ULONG <VAR
CLASS="PDPARAM"
>type</VAR
>, LONG <VAR
CLASS="PDPARAM"
>priority</VAR
>, APTR <VAR
CLASS="PDPARAM"
>address</VAR
>, STRPTR <VAR
CLASS="PDPARAM"
>name</VAR
>);</CODE
></P
><P
></P
></DIV
>
          adds memory to the list of free memory in the system. You have
          supply the <TT
CLASS="PARAMETER"
><I
>address</I
></TT
> and the
          <TT
CLASS="PARAMETER"
><I
>size</I
></TT
> of the memory to add.
          <TT
CLASS="PARAMETER"
><I
>type</I
></TT
> has to be set to at least one of the
          <A
HREF="exec-memory-h.html#EXEC-MEMORY-MEMF"
><SPAN
CLASS="SYMBOL"
>MEMF_</SPAN
></A
> flags,
          which are defined in <A
HREF="exec-memory-h.html"
><TT
CLASS="FILENAME"
>exec/memory.h</TT
></A
>:
          <P
></P
><DL
><DT
><SPAN
CLASS="SYMBOL"
>MEMF_FAST</SPAN
></DT
><DD
><P
>Your memory must not be accessed by graphics or
              sound chips.</P
></DD
><DT
><SPAN
CLASS="SYMBOL"
>MEMF_CHIP</SPAN
></DT
><DD
><P
>Your memory is reachable by graphics and sound
              chips.</P
></DD
></DL
></P
><P
>You can provide a <TT
CLASS="PARAMETER"
><I
>priority</I
></TT
>, with which
          your memory will be added to the memory list. The general rule is:
          The quicker your memory, the higher the priority should be. If you
          don't know, what to supply here, supply <TT
CLASS="LITERAL"
>0</TT
>.
          Finally, you can provide a <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>, with which
          your memory can be identified by the system and its users. You may
          provide <SPAN
CLASS="SYMBOL"
>NULL</SPAN
> instead of a name, but giving your
          memory a name is recommended.</P
><P
>Once your memory was added to the list of free memory, it
          can't be removed anymore.</P
></DIV
>


        <DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1001"
>Low Memory Situations</A
></H2
><P
>FIXME: AddMemHandler()/RemMemHandler()</P
></DIV
>
      </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="chap-memory.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="chap-files.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Exec Lists and Memory Management</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="chap-memory.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Files and Directories</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>