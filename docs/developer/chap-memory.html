<HTML
><HEAD
><TITLE
>Exec Lists and Memory Management</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.42"><LINK
REL="HOME"
TITLE="The Amiga Research OS"
HREF="book1.html"><LINK
REL="UP"
TITLE="Concepts"
HREF="part-concepts.html"><LINK
REL="PREVIOUS"
TITLE="Giving Additional Arguments with Taglists"
HREF="sect-taglists.html"><LINK
REL="NEXT"
TITLE="Memory Handling"
HREF="sect-memory.html"></HEAD
><BODY
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
><SPAN
CLASS="PRODUCTNAME"
>The Amiga Research OS</SPAN
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="sect-taglists.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="sect-memory.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="CHAP-MEMORY"
>Chapter 3. Exec Lists and Memory Management</A
></H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="chap-memory.html#SECT-LISTS"
>Exec Lists</A
></DT
><DT
><A
HREF="sect-memory.html"
>Memory Handling</A
></DT
></DL
></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="SECT-LISTS"
>Exec Lists</A
></H1
><P
><SPAN
CLASS="ACRONYM"
>AROS</SPAN
> implements a system of
        <I
CLASS="FIRSTTERM"
>linked lists</I
>, so-called <I
CLASS="FIRSTTERM"
>exec lists</I
>.
        A linked-list consists of a number of <I
CLASS="FIRSTTERM"
>nodes</I
>
        that point to each other. Two types of nodes are defined in
        <A
HREF="exec-nodes-h.html"
><TT
CLASS="FILENAME"
>exec/nodes.h</TT
></A
>:
        <P
></P
><UL
><LI
><P
>struct <SPAN
CLASS="STRUCTNAME"
>MinNode</SPAN
> is the basic
          node. You don't need to know about its structure, since every
          possible action on them is handled by some library function.</P
></LI
><LI
><P
>struct <SPAN
CLASS="STRUCTNAME"
>Node</SPAN
> extends the
          simple struct <SPAN
CLASS="STRUCTNAME"
>MinNode</SPAN
>. It provides some
          additional fields:
          <P
></P
><DL
><DT
><TT
CLASS="STRUCTFIELD"
><I
>ln_Name</I
></TT
></DT
><DD
><P
>Each <SPAN
CLASS="STRUCTNAME"
>Node</SPAN
> contains a
              pointer to a string, describing that node.</P
></DD
><DT
><TT
CLASS="STRUCTFIELD"
><I
>ln_Type</I
></TT
></DT
><DD
><P
><A
HREF="exec-nodes-h.html#EXEC-NODES-TYPES"
>A list of
              types</A
> is defined in <TT
CLASS="FILENAME"
><A
HREF="exec-nodes-h.html"
>exec/nodes.h</A
></TT
>.
              </P
></DD
><DT
><TT
CLASS="STRUCTFIELD"
><I
>ln_Pri</I
></TT
></DT
><DD
><P
>A priority, used for sorting the list.</P
></DD
></DL
>
        </P
></LI
></UL
></P
><P
>Both structures can be embedded into other structures. For
        example <A
HREF="exec-libraries-h.html#EXEC-LIBRARIES-LIBRARY"
>struct
        <SPAN
CLASS="STRUCTNAME"
>Library</SPAN
></A
> (defined in
        <A
HREF="exec-libraries-h.html#EXEC-LIBRARIES-LIBRARY"
><TT
CLASS="FILENAME"
>exec/libraries.h</TT
></A
>)
        contains a struct <SPAN
CLASS="STRUCTNAME"
>Node</SPAN
> at the beginning. This
        way all libraries can be contained in a list. The field
        <TT
CLASS="STRUCTFIELD"
><I
>ln_Name</I
></TT
> points to the name of the library,
        <TT
CLASS="STRUCTFIELD"
><I
>ln_Type</I
></TT
> is set to <SPAN
CLASS="SYMBOL"
>NT_LIBRARY</SPAN
>
        to show that this node is a library and
        <TT
CLASS="STRUCTFIELD"
><I
>ln_Pri</I
></TT
> reflects the
        <I
CLASS="EMPHASIS"
>importance</I
> of a library.</P
><P
>Of course, we need a list containers. These are defined in
        <A
HREF="exec-lists-h.html"
><TT
CLASS="FILENAME"
>exec/lists.h</TT
></A
>.
        Like nodes, we have two different kind of lists:
        <P
></P
><UL
><LI
><P
>struct <SPAN
CLASS="STRUCTNAME"
>MinList</SPAN
> is the
          minimal list. You do not need to know about its members; look at
          it as a black-box.</P
></LI
><LI
><P
>struct <SPAN
CLASS="STRUCTNAME"
>List</SPAN
> contains an
          additional field <TT
CLASS="STRUCTFIELD"
><I
>lh_Type</I
></TT
>, which
          corresponds to <TT
CLASS="STRUCTFIELD"
><I
>ln_Type</I
></TT
> of
          struct <SPAN
CLASS="STRUCTNAME"
>Node</SPAN
>.</P
></LI
></UL
></P
><P
><SPAN
CLASS="STRUCTNAME"
>MinList</SPAN
>s take <SPAN
CLASS="STRUCTNAME"
>MinNode</SPAN
>s
        as members, while <SPAN
CLASS="STRUCTNAME"
>List</SPAN
>s use <SPAN
CLASS="STRUCTNAME"
>Node</SPAN
>s.
        They are not interchangeable. While it's technically possible to use
        <SPAN
CLASS="STRUCTNAME"
>Node</SPAN
>s in <SPAN
CLASS="STRUCTNAME"
>MinList</SPAN
>s,
        you loose all their advantages.</P
><P
>FIXME: Macros</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN504"
>List Manipulating Functions</A
></H2
><P
><TT
CLASS="FILENAME"
>exec.library</TT
> and the link-library
          <TT
CLASS="FILENAME"
>amiga.lib</TT
> contain some functions for manipulating
          exec lists. Before a list can be used, it <I
CLASS="EMPHASIS"
>must</I
> be
          initialized, using
          the <TT
CLASS="FILENAME"
>amiga.lib</TT
> function
          <DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;proto/alib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>NewList</B
></CODE
>(struct List * <VAR
CLASS="PDPARAM"
>list</VAR
>);</CODE
></P
><P
></P
></DIV
></P
><P
>Nodes can be added to lists with the <TT
CLASS="FILENAME"
>exec.library</TT
>
          functions
          <DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;proto/exec.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>AddHead</B
></CODE
>(struct List * <VAR
CLASS="PDPARAM"
>list</VAR
>, struct Node * <VAR
CLASS="PDPARAM"
>node</VAR
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>AddTail</B
></CODE
>(struct List * <VAR
CLASS="PDPARAM"
>list</VAR
>, struct Node * <VAR
CLASS="PDPARAM"
>node</VAR
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>Enqueue</B
></CODE
>(struct List * <VAR
CLASS="PDPARAM"
>list</VAR
>, struct Node * <VAR
CLASS="PDPARAM"
>node</VAR
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>Insert</B
></CODE
>(struct List * <VAR
CLASS="PDPARAM"
>list</VAR
>, struct Node * <VAR
CLASS="PDPARAM"
>node</VAR
>, struct Node * <VAR
CLASS="PDPARAM"
>pred</VAR
>);</CODE
></P
><P
></P
></DIV
>
          With <TT
CLASS="FUNCTION"
>AddHead()</TT
> and <TT
CLASS="FUNCTION"
>AddTail()</TT
>
          <TT
CLASS="PARAMETER"
><I
>node</I
></TT
> is inserted at the beginning or the end
          of <TT
CLASS="PARAMETER"
><I
>list</I
></TT
> respectively. <TT
CLASS="FUNCTION"
>Enqueue()</TT
>
          inserts <TT
CLASS="PARAMETER"
><I
>node</I
></TT
> according to its
          <TT
CLASS="STRUCTFIELD"
><I
>ln_Pri</I
></TT
> field. A node can be inserted after
          another by using <TT
CLASS="FUNCTION"
>Insert()</TT
>. A pointer to the
          node that is to predecess <TT
CLASS="PARAMETER"
><I
>node</I
></TT
> must be provided
          as <TT
CLASS="PARAMETER"
><I
>pred</I
></TT
>.</P
><P
>Nodes can be removed using the <TT
CLASS="FILENAME"
>exec.library</TT
>
          functions
          <DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;proto/exec.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>Remove</B
></CODE
>(struct Node * <VAR
CLASS="PDPARAM"
>node</VAR
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>struct Node * <B
CLASS="FSFUNC"
>RemHead</B
></CODE
>(struct List * <VAR
CLASS="PDPARAM"
>list</VAR
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>struct Node * <B
CLASS="FSFUNC"
>RemTail</B
></CODE
>(struct List * <VAR
CLASS="PDPARAM"
>list</VAR
>);</CODE
></P
><P
></P
></DIV
>
          While <TT
CLASS="FUNCTION"
>RemHead()</TT
> and <TT
CLASS="FUNCTION"
>RemTail()</TT
>
          remove the first or last node of a <TT
CLASS="PARAMETER"
><I
>list</I
></TT
>
          respectively and return a pointer to it, <TT
CLASS="FUNCTION"
>Remove()</TT
>
          removes <TT
CLASS="PARAMETER"
><I
>node</I
></TT
> from whatever list it is in.</P
><P
>Of course, all list functions (except <TT
CLASS="FUNCTION"
>Enqueue())</TT
>
          can process struct <SPAN
CLASS="STRUCTNAME"
>MinList</SPAN
>s and
          struct <SPAN
CLASS="STRUCTNAME"
>MinNode</SPAN
>s, too.</P
><P
>A list can be searched for a named node, using
          <DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;proto/exec.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>struct Node * <B
CLASS="FSFUNC"
>FindName</B
></CODE
>(struct List * <VAR
CLASS="PDPARAM"
>list</VAR
>, STRPTR <VAR
CLASS="PDPARAM"
>name</VAR
>);</CODE
></P
><P
></P
></DIV
>
          <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> is a pointer to a string that is to be
          compared with the <TT
CLASS="STRUCTFIELD"
><I
>ln_Name</I
></TT
> of the nodes
          in <TT
CLASS="PARAMETER"
><I
>list</I
></TT
>. The comparison is case-sensitive!
          If <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> matches any <TT
CLASS="STRUCTFIELD"
><I
>ln_Name</I
></TT
>
          field, a pointer to the corresponding node is returned. If no field
          matches, <SPAN
CLASS="SYMBOL"
>NULL</SPAN
> is returned.

          <DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>A list used with <TT
CLASS="FUNCTION"
>FindName()</TT
> must not
          contain any struct <SPAN
CLASS="STRUCTNAME"
>MinList</SPAN
> entries. If it
          does, memory could get corrupted!</P
></BLOCKQUOTE
></DIV
>

          <P
>In the following example, we create a list, add three nodes to
          it, search a named node and then remove it.</P
>

          <DIV
CLASS="EXAMPLE"
><P
><B
>Example 3-1. List example</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#include &#60;proto/alib.h&#62;
#include &#60;proto/exec.h&#62;
#include &#60;exec/types.h&#62;
#include &#60;exec/lists.h&#62;
#include &#60;exec/nodes.h&#62;
#include &#60;dos/dos.h&#62;    /* For RETURN_OK */

struct List list;

/* Our nodes */
struct Node node1 =
{
    NULL, NULL,    /* No predecessor and successor, yet */
    NT_UNKNOWN, 0, /* Unknown type, priority ignored */
    "First node"   /* Name of the node */
};

struct Node node2 =
{
    NULL, NULL,
    NT_UNKNOWN, 0,
    "Second node"
};

struct Node node3 =
{
    NULL, NULL,
    NT_UNKNOWN, 0,
    "Third node"
};


int main(int argc, char *argv[])
{
    struct Node *node;

    /* Prepare the list for use. */
    NewList(&#38;list);

    /* Add the first two nodes at the end of the list. */
    AddTail(&#38;list, &#38;node1);
    AddTail(&#38;list, &#38;node2);

    /* Insert the third node after the first node. */
    Insert(&#38;list, &#38;node3, &#38;node1);

    /* Find the second node */
    node = FindName(&#38;list, "Second node");

    /* If the node was found (which is always the case in this example),
       remove it.
    */
    if (node)
        Remove(&#38;node);

    return RETURN_OK;
}
            </PRE
></TD
></TR
></TABLE
></DIV
>
        </P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sect-taglists.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sect-memory.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Giving Additional Arguments with Taglists</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="part-concepts.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Memory Handling</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>