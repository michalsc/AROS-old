<HTML
><HEAD
><TITLE
>Tasks, Processes and the Shell</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.42"><LINK
REL="HOME"
TITLE="The Amiga Research OS"
HREF="book1.html"><LINK
REL="UP"
TITLE="Concepts"
HREF="part-concepts.html"><LINK
REL="PREVIOUS"
TITLE="Low Level File Access (Filehandlers)"
HREF="x1032.html"><LINK
REL="NEXT"
TITLE="Processes"
HREF="sect-processes.html"></HEAD
><BODY
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
><SPAN
CLASS="PRODUCTNAME"
>The Amiga Research OS</SPAN
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x1032.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="sect-processes.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="CHAP-TASKS"
>Chapter 5. Tasks, Processes and the Shell</A
></H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="chap-tasks.html#SECT-TASKS"
>Tasks</A
></DT
><DT
><A
HREF="sect-processes.html"
>Processes</A
></DT
><DT
><A
HREF="x1191.html"
>Creating own Tasks and Processes</A
></DT
><DT
><A
HREF="x1204.html"
>Local and Global Variables</A
></DT
><DT
><A
HREF="x1207.html"
>Expanded Error Diagnostics</A
></DT
><DT
><A
HREF="x1275.html"
>Parsing Arguments</A
></DT
><DT
><A
HREF="x1278.html"
>Inter-Process and -Task Communication</A
></DT
><DT
><A
HREF="x1287.html"
>Multitasking Issues</A
></DT
><DT
><A
HREF="sect-shell.html"
>Shell</A
></DT
></DL
></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="SECT-TASKS"
>Tasks</A
></H1
><P
><SPAN
CLASS="ACRONYM"
>AROS</SPAN
> is a multitasking operating
        system. This essentially means that multiple programs may be run at
        the same time. Every program running is called a task. But there are
        also tasks that are not user-programs. There are, for example, tasks
        handling the file-system and tasks watching the input devices. Every
        task gets a certain amount of time, in which it is running. After this
        time it's the next task's turn; the system <I
CLASS="FIRSTTERM"
>reschedules</I
>
        the tasks.</P
><P
>Plain tasks are very limited in their capabilities. Plain tasks
        must not call a function of <TT
CLASS="FILENAME"
>dos.library</TT
>
        or a function that could call a function of <TT
CLASS="FILENAME"
>dos.library</TT
>
        (this includes <TT
CLASS="FUNCTION"
>OpenLibrary()</TT
> for most cases!).
        <A
HREF="sect-processes.html"
><I
CLASS="FIRSTTERM"
>Processes</I
></A
>
        don't have this limitation.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1048"
>The Task Structure</A
></H2
><P
>A task is described by a struct <SPAN
CLASS="STRUCTNAME"
>Task</SPAN
>
          as defined in <A
HREF="exec-tasks-h.html#EXEC-TASKS-TASK"
><TT
CLASS="FILENAME"
>exec/tasks.h</TT
></A
>.
          This structure contains information about the task like the
          its <A
HREF="chap-tasks.html#AEN1135"
>stack</A
>, its
          <A
HREF="x1278.html#SECT-SIGNALS"
>signals</A
> and some management
          data. To get the address of a task strucure, use
          <DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;proto/exec.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>struct Task * <B
CLASS="FSFUNC"
>FindTask</B
></CODE
>(STRPTR <VAR
CLASS="PDPARAM"
>name</VAR
>);</CODE
></P
><P
></P
></DIV
>
          <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> is a pointer to the name of the task to
          find. <I
CLASS="EMPHASIS"
>Note that this name is case-sensitive!</I
>
          If the named task is not found, <SPAN
CLASS="SYMBOL"
>NULL</SPAN
> is returned,
          otherwise a pointer to a struct <SPAN
CLASS="STRUCTNAME"
>Task</SPAN
>.</P
><P
>To get a pointer to the current task, supply
          <SPAN
CLASS="SYMBOL"
>NULL</SPAN
> as <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>. This can never
          fail.</P
><P
>The task structure contains a field called
          <TT
CLASS="STRUCTFIELD"
><I
>tc_UserData</I
></TT
>. You can use it for your own
          purposes. It is ignored by <SPAN
CLASS="ACRONYM"
>AROS</SPAN
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1073"
>States</A
></H2
><P
>A task must be in one of following states (as set in the field
          <TT
CLASS="STRUCTFIELD"
><I
>tc_State</I
></TT
> of the task structure):
          <P
></P
><DL
><DT
><SPAN
CLASS="SYMBOL"
>TS_INVALID</SPAN
></DT
><DD
><P
>This state should never be set!</P
></DD
><DT
><SPAN
CLASS="SYMBOL"
>TS_ADDED</SPAN
></DT
><DD
><P
>FIXME</P
></DD
><DT
><SPAN
CLASS="SYMBOL"
>TS_RUN</SPAN
></DT
><DD
><P
>The task is currently running. On single
              processor architectures only one task can be in that state.</P
></DD
><DT
><SPAN
CLASS="SYMBOL"
>TS_READY</SPAN
></DT
><DD
><P
>The task waits for its execution.</P
></DD
><DT
><SPAN
CLASS="SYMBOL"
>TS_WAIT</SPAN
></DT
><DD
><P
>The task waits for some <A
HREF="x1278.html#SECT-SIGNALS"
>signal</A
>
              to get activated. As long as this does not happen, the program
              doesn't become active; it is ignored on rescheduling. Most
              interactive programs are in this state most of the time, as
              they wait for user input.</P
></DD
><DT
><SPAN
CLASS="SYMBOL"
>TS_EXCEPT</SPAN
></DT
><DD
><P
>The task is in an exception.</P
></DD
><DT
><SPAN
CLASS="SYMBOL"
>TS_REMOVED</SPAN
></DT
><DD
><P
>FIXME</P
></DD
></DL
></P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>Do not set these states yourself, unless you know
          exactly what you are doing!</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1116"
>Priorities</A
></H2
><P
>The field <TT
CLASS="STRUCTFIELD"
><I
>tc_Node.ln_Pri</I
></TT
> of the
          struct <SPAN
CLASS="STRUCTNAME"
>Node</SPAN
> embedded in the task structure
          (see <A
HREF="exec-nodes-h.html#EXEC-NODES-NODE"
><TT
CLASS="FILENAME"
>exec/nodes.h</TT
></A
>
          and the <A
HREF="chap-memory.html#SECT-LISTS"
>section about exec lists</A
>)
          specifies the priority of the task. Possible priorities reach from
          <TT
CLASS="LITERAL"
>-128</TT
> to <TT
CLASS="LITERAL"
>127</TT
>. The higher the
          priority the more processor time the task gets from the system. To
          set a task's priority use the function
          <DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;proto/exec.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>BYTE <B
CLASS="FSFUNC"
>SetTaskPri</B
></CODE
>(struct Task * <VAR
CLASS="PDPARAM"
>task</VAR
>, BYTE <VAR
CLASS="PDPARAM"
>newpri</VAR
>);</CODE
></P
><P
></P
></DIV
>
          The old priority is returned.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1135"
>Stack</A
></H2
><P
>Every task has a stack. A stack is a piece of memory, in
          which a tasks stores its temorary data. Compilers, for example,
          use the stack to store variables, you use in your programs. On
          many architectures, the stack is also used to supply library
          functions with parameters.</P
><P
>The size of the stack is limited. Therefore only a certain
          amount of data can be stored in the stack. The stack-size of a
          task is chosen by its caller and must be at least 4096 bytes. Tasks
          should generally not assume that their stack-size is bigger. So,
          if a task needs more stack, the stack can be exchanged by using the
          function
          <DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;proto/exec.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>StackSwap</B
></CODE
>(struct StackSwapStruct * <VAR
CLASS="PDPARAM"
>sss</VAR
>);</CODE
></P
><P
></P
></DIV
>
          The only argument, <TT
CLASS="PARAMETER"
><I
>sss</I
></TT
>, is a pointer to a
          struct <SPAN
CLASS="STRUCTNAME"
>StackSwapStruct</SPAN
> as defined in
          <A
HREF="exec-tasks-h.html#EXEC-TASKS-STACKSWAPSTRUCT"
><TT
CLASS="FILENAME"
>exec/tasks.h</TT
></A
>.</P
><P
>struct <SPAN
CLASS="STRUCTNAME"
>StackSwapStack</SPAN
> must contain a
          pointer to the beginning of the new stack (<TT
CLASS="STRUCTFIELD"
><I
>strk_Lower</I
></TT
>),
          to the end of the new stack (<TT
CLASS="STRUCTFIELD"
><I
>stk_Upper</I
></TT
>)
          and a new stack-pointer (<TT
CLASS="STRUCTFIELD"
><I
>stk_Pointer</I
></TT
>).
          This stack-pointer is normally set either to the same address as
          <TT
CLASS="STRUCTFIELD"
><I
>stk_Lower</I
></TT
> or to the same address as
          <TT
CLASS="STRUCTFIELD"
><I
>stk_Upper</I
></TT
>, depending on the kind of
          <SPAN
CLASS="ACRONYM"
>CPU</SPAN
> used.</P
><P
>When calling <TT
CLASS="FUNCTION"
>StackSwap()</TT
>, the
          <SPAN
CLASS="STRUCTNAME"
>StackSwapStruct</SPAN
> structure supplied as
          <TT
CLASS="PARAMETER"
><I
>sss</I
></TT
> will be filled with information
          about the current stack.</P
><P
>After finishing using the new stack, the old stack must be
          restored by calling <TT
CLASS="FUNCTION"
>StackSwap()</TT
> a second time
          with the same <SPAN
CLASS="STRUCTNAME"
>StackSwapStruct</SPAN
>.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>Normally, only compilers need this function. Handle
          it with great care as different architectures use the stack in
          different ways!</P
></BLOCKQUOTE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x1032.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sect-processes.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Low Level File Access (Filehandlers)</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="part-concepts.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Processes</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>