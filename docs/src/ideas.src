\chapter{Random Ideas}
\section{Introduction}

This part of the documentation for AROS contains random and unsorted and
possibly impossible improvements, ideas and other things which might
go into AROS V2.x, when compatibility with AmigaOS is still important but
where new things can be done.

\begin{itemize}
\item By Nils Henrik Lorentzen: All lists and public structures must be protected by semaphore. A
system like the hierarchical semaphores in pOS would be best.
\item By Claus Herrmann and Iain Templeton:
lddaemon should be able to load more than one library at a time thus
allowing to open a library which has to be loaded from disk which opens a
library in |libOpen()| which has also to be loaded from disk.

The daemon could also search actively for a library allowing the user to
specify one if it can't be found. Paths like \shell{PROGDIR:} should be
searched automatically.

If the lib can't be found, DOS_OpenLibrary() must create a message port and
a message, put the port in the reply-to field of the message as well as the
name and min-version of the lib and then send the message to the lddaemon
and wait for the reply.

Open questions: Will this interfere with the way Exec handles libraries now
(eg. single threaded |libInit()|) ? Can this introduce deadlocks in the
locking of the exec library list ? What happens if |libClose()| calls
|libExpunge()| ?
\item
By Nils Henrik Lorentzen: Extend on the
datatypes concept. Some datatypes-alike system where dataprocessing methods
can be added to datatype classes. (Eg. for pictures one could add methods
like |Rotate()|, |Flip()| and other typical image processing operators.
Similarly one can add sound fx methods for sound data). For this to be
usefull one should probably be able to add methods to a class one by one
(so BOOPSI can probably not be used for this).

The objects should contain the data in a raw format so that the methods
can easily operate on it. One should be able to stream data in and out
of the objects. One could have separate "converter objects" that
can convert from a data format (eg. GIF->internal raw image format
and back eg. raw->GIF.) So when you want to put a GIF file into
an image object the system will automatically search for installed
gif->internal raw converters and convert the GIF into a stream of
raw image data passed to the image object.

These data objects should of course have methods like |Show()|
and |Edit()|. |Edit()| could invoke your favourite
texteditor/paintprogram/drawprogram/etc depending on the
object type. (text/image/structured drawing).

Now, should these objects be able to show themselves,
like the old datatypes ? Well, IMO they should not be bound to
a single operating system/GUI system, but they could maybe show
themselves through some RTG system (?).
But the viewer could also stream out the data from
the object to show. When the object's data has changed, the
viewer could be notified and where in the stream the "damaged" data is.
(If a text viewer GUI views the first 100 lines of a 100000 line
text data object, and the last 100 lines are changed, it wouldn't
need to rerender).

As mentioned earlier one should be able to use this system
on different OSes, and it should maybe also be possible to
invoke methods on them over a network or even move the objects
in a network (using CORBA ?). This way a heavy operation on
the data object can be done on a faster machine while you are
controlling it from a slower machine.

By keeping functionality into small components, 3rd party
programmers can easily write freeware additional functionality.
(One can add methods operating on the data one at a time.)
It will provide very much reuse of code. (Just look around on
Aminet: There are whole bunch of different image processing
programs that implement the same functionality. This
should really only have to be written once).
If the system can work on other platforms too, we get even
more developers that can support it.

I believe that if some system should have any chance at all
of taking some market share from M$ it	a) has to be free.
b) must be available on as many platforms as possible. c) must consist
of tiny components that can be added at run-time.=>This way it'll be
easier for developers to support it.

\item
By Aaron Digulla:
When a new HIDD is installed, it should appear in the list of
available HIDDs automatically (eg. by file notification on the directory).

\item
By Aaron Digulla:
We need an automatic converter for the incompatible features of AROS
to convert the old AmigaOS code to AROS (which can then be compiled on
AmigaOS by our compatibility lib).

\item
By Bernhard Fastenrath:
I wanted to have a select() for AmigaOS filedescriptors some time ago, that's
why I wrote the AbortPkt() patch which sends an ACTION_ABORT.

A select/asyncio handler (AsyncIO.hidd ?) which handles allocation of buffers
and IO on multiple handlers could allocate buffers, do multiple reads on behalf
of a process and signal the process when input is available. The same would
happen for write operations (writing would block when the select handler has
queued a maximum of bytes or buffers for a single process).

A process that wants to exit could just close the select handler and leave it
to the handler to deallocate the buffers when they are returned one day ...
Under AROS the handler would be able to use AbortPkt() and under AmigaOS it
would be able to use it if the patch is installed and the underlying handler
accepts the packet type ACTION_ABORT.

The idea reminds me a bit of Unix STREAMS or NT device drivers: both pass
packets through several layers of device abstractions. UnixIO could be one
layer below the select handler and would translate it to a real select()
because the buffer mechanism of the select handler is part of the Unix kernel
anyway; so a write would block when the kernel buffers are full, as usual.

\item
By Aaron Digulla:
I'm thinking about something called "cache memory". It should use all free
memory to store "nice to have" data like for read ahead or write through
caches for disks and harddisk or a printer spooler.

This memory is allocated by special functions. It doesn't appear in the
"memory used" list but is added to the amount of free memory. Besides
allocation and freeing there are two special cases. The simple one is that
some other application needs the RAM, so parts of the cache have to be
purged. The other one is to avoid memory fragmentation. It's not possible
or useful to use all the free memory for caching. So the cache should
always be one large block divided up in several smaller chunks. If an
application needs memory, parts of the cache have to be freed *or* they
have to be copied in unused chunks (eg. it's still faster to copy 512 bytes
than to read them back from HD or a printer spooler should not throw the
spooled data away).

\item
By Paulo F. Zemek:
The Amiga
has the Smart refreshed windows that uses an own bitmap and the Simple, that
need to be refreshed because it uses the screen bitmap. I want a Double
Buffered one. A simple refresh window where you allocate a bitmap and a
rastport for it, and this will be send to window on Refresh (or in window's
BackFill Hook) and when the Draw of All Buttons are finished, so you don't
get "flickering" (I don't know the correct word) on the graphic, and uses
almost the same memory of a Smart one.

\item
By Paulo F. Zemek:
The amiga needs a function for opening windows into other windows like on
windows. The "Requester" does this, but stops the functionality of the
window, and doesn't have all Attributes of a real window. This or something
like this is needed for buttons which are over others, so the graphic of the
"bottom" one will not pass over the front one. And can be created new
functions for opening Windows/Screens, so you can convert a window into a
screen, create Public Windows and open other windows on it...

[Aaron Digulla: This is dangerous; it uses a lot of memory, adds many
IDCMP event loops and the same effect can be achieved when using
clip regions; all we have to do is to make the gadgets public, which render a
window, plus maybe a BOOPSI subwindow class which installs a clip region
in another window.]

\item
By Paulo F. Zemek:
exec.library can have an EnqueueTail, and this
is easy to do, so the Enqueue already exists.

\item
By Paulo F. Zemek:
Intuition should not send more than one REFRESH message to a window (ie.
if there is already one in the queue, then it should be removed first).

\item
By Denis Bucher:
|OpenLibrary()|, etc. should check for libraries in various places.
It should be possible to add paths for these and similar functions
and there should be a tool which checks and tells which library, etc.
would be opened (eg. the path is \shell{libs,PROGDIR:libs,libs:} and there
is a \filename{x.library} in \filename{libs} and \filename{libs:}. The tool
should tell which one
is opened and why (ie. \shell{loading libs:x.library over libs/x.library
because: libs:x.library has version 41.0 and libs/x.library has
39.20}).

By Aaron Digulla:
It should be possible to protect some files (like libraries) so
that you need to call a specific OS/FS function to replace them.
This would allow to fix all problems with tools replacing libraries
with old versions. Maybe even a patch to |Open()| would be enough
which checks if someone tries to write in a specific directory
and calls a tool which checks if the write is ok. This is of course
a bit dangerous.

\item
By Henning Kiel:
The original Amiga Includes used to have an intuition/iobsolete.h
AROS wants to get rid of obsolete stuff, and therefore we are not going
to include iobsolete.h in our distribution. However, we are intersted in
getting software for AROS and this may be old, but useful.
So we need a way to support old sources, but in such a way, that the old
code will be converted. (Maybe in multiple passes)
This conversion-tool should do: (open, unordered list)
\begin{itemize}
\item convert old defines to new ones
\item convert old storage types (e.g. SHORT to WORD)
\end{itemize}

\item
By Dave Haynie:
Stuff we spoke about over lunch, dating back to our days consulting for
Amiga Technologies. Andy mentioned the model they use for the 3DO
operating system (the original one, not the M2 version, which is
supposedly more like the BeOS).

In this system, each process has its own memory map, but the actual
mapping is still global (eg, there's just one memory space). Your
process can see the rest of the world as read-only. Functions like
AllocMem() transparently work from local memory pools attached to your
process, so things stay nicely page-aligned. This has the secondary
effect of making AllocMem() faster than it is today, since you only have
to involve Exec proper (locking the system up to keep things atomic)
every so often, not at every AllocMem().

I would make the extension to this that memory contexts become first-class
Exec objects. The System context would be the "root", with read/write
access as we have today. Device drivers that need the direct access to
hardware, or the performance of using references rather than copies, could
be started on this context. You could build alternate contexts, such as the
read-only underlay, as mentioned, or even fully private memory spaces, as
in UNIX. Obviously this is for new code, and Exec would need to add/enhance
functions for sending messages, copying, etc. between memory spaces. But
since you're not expecting any old code to run in a fully separate space,
some of today's bad habits wouldn't really be an issue.

\item
By Sebastian Rittau: Maybe we could rewrite Installer as library, which
provides functions that are currently contained in Installers language.
This would allow programmers to easily write Installer scripts in their
prefered programming language, instead of learning Installer's own
language.

While doing this, we could also add methods to uninstall an installed
package.

\item
By Aaron Digulla: There should be a tool to create a kernel which can be
put into a Flash ROM or EEPROM or a boot file. The tool should be able to
fix all absolute addresses in the kernel, it should be able to create the
resident tags or a simple file system which allows the boot loader to
find, load and init all parts it needs.

The main reasons for this are: When you add a new driver (eg. a harddisk
controller), you don't want to have to install a C compiler just to be able
to boot from it. The ordinary user just wants to call a "install driver"
tool which does all the work without him worrying. Also to reduce similar
code, the boot loader will probably use the same code to load drivers
as will the OS. So the "file system" which is visible to the boot loader
must be similar to what the OS sees. This becomes more important if some
driver in the ROM is not loaded/inited during booting. Then the OS will
use its normal ways to search for the driver and at this time, the
driver must be visible by some file system-like means or the searching
for it will fail.

\item
\begin{new}{24.1.2000}
By: Aaron Digulla
Date: Fri, 23 Oct 1998
Subject: [aros-dev] Shared libs/objects idea

An idea just stuck me which *might* safe us a lot of trouble.

We should separate the code from the interface. Code is here: The
code for the ROM libraries and interface is here the Exec shared
library interface.

As you might remember, I dream about AROS as native emulation (ie.
compile Amiga apps which run as native apps without arosshell).

Most of the problems we have right now (eg. in the mmakefiles)
come from the fact that we can't use the systems' own way to
work with shared objects but that we try to emulate Exec's way.

IMHO, it would be much better if we did this:

exec becomes a plain exec.lib which contains normal functions.
Then we create an interface for these normal functions and this
interface can be accessed as exec.library. All we have to do now
is to link the interface with the standard library. If we don't
need the interface (eg. because we have a cool autoinit feature
like the dynamic loader from Unix), we can omit it.

This way, we could separate the amiga-specific parts of AROS
much better from the portable parts. Also, it would be possible
to create different interfaces much better. And the interface
wouldn't be intermixed with the portable code as it is now.
\end{new}

\item
\begin{new}{24.1.2000}
By: Aaron Digulla
Date: Wed, 3 Mar 1999 10:25:09 +0100
Subject: [aros-dev] Idea: Configuration Database

Ok, since the topic has been brought up: Here is something which I'm
missing in the current config DBs/registries:

There should be a way to keep histories of configurations plus
"commit logs". Basically, the whole config should work with CVS.
That would make debugging much more simple (just throw anything
out and when it works again, do a diff to see what has changed).
It would also answer the question "why did I disable that" ?

And with tags, you can name stable states of the config and
switch between them.
\end{new}

\end{itemize}
