/*
    (C) 2000 AROS - The Amiga Research OS
    $Id$

    Desc: DataTypesDescriptorExaminator
    Lang: English.
*/

/*
 *  includes
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <c_iff.h>

/*
 *  structs
 */

struct DataTypeHeader
{
 char *dth_Name;
 char *dth_BaseName;
 char *dth_Pattern;
 short *dth_Mask;
 unsigned long dth_GroupID;
 unsigned long dth_ID;
 short dth_MaskLen;
 short dth_Pad;
 unsigned short dth_Flags;
 unsigned short dth_Priority;
};

/*
 *  prototypes
 */

void PrintID(unsigned long ID, unsigned char *Buffer);

/*
 *  functions
 */

int main(int argc, char **argv)
{
 struct IFFHandle *IH;
 char Buffer[128];
 char *DTDName;
 size_t NameLength;
 FILE *TheOut, *Out;
 unsigned char ID[5];
 int i;

 Out=stdout;

 if(!(argc==2))
 {
  fprintf(stderr, "usage: %s datatypedescriptor\n", argv[0]);
  return(0);
 }

 IH=OpenIFF(argv[1]);
 if(!IH)
 {
  fprintf(stderr, "Could not open %s\n", argv[1]);
  return(0);
 }

 if(!(IH->IFFType==MAKE_ID('D','T','Y','P')))
 {
  fprintf(stderr, "This IFF is not a valid DataType-Descriptor\n");
  return(0);
 }

 TheOut=NULL;

 NameLength=strlen(argv[1])+4;
 DTDName=malloc(NameLength);
 if(DTDName)
 {
  memset(DTDName, '\0', NameLength);
  strcpy(DTDName, argv[1]);
  strcat(DTDName, ".dtd");
  TheOut=fopen(DTDName, "wb");
  if(TheOut)
  {
   Out=TheOut;
  }
  free((void *) DTDName);
 }

 fprintf(Out, "# DataTypeDescription for %s\n", argv[1]);
 fprintf(Out, "# Automatically generated by %s\n\n", argv[0]);

 while(TRUE)
 {
  if(!ReadChunkHeader(IH))
  {
   break;
  }

  switch(IH->ChunkID)
  {
   case MAKE_ID('F','V','E','R'):
   {
    long Size;
    char Buffer[128];

    fprintf(Out, "Version=");

    while(TRUE)
    {
     Size=ReadChunkData(IH, Buffer, 127);
     if(Size<=0)
     {
      break;
     }

     Buffer[Size]='\0';
     fprintf(Out, "%s", Buffer);
    }

    fprintf(Out, "\n");

    SkipChunkData(IH);
    break;
   }

   case MAKE_ID('N','A','M','E'):
   {
    long Size;

    fprintf(Out, "Name=");

    while(TRUE)
    {
     Size=ReadChunkData(IH, Buffer, 127);
     if(Size<=0)
     {
      break;
     }

     Buffer[Size]='\0';
     fprintf(Out, "%s", Buffer);
    }

    fprintf(Out, "\n");

    SkipChunkData(IH);
    break;
   }

   case MAKE_ID('D','T','H','D'):
   {
    struct DataTypeHeader *DTH;
    unsigned char *DTHDBuffer;
    long Size;

    DTHDBuffer=malloc(IH->BytesLeftInChunk);
    if(!DTHDBuffer)
    {
     goto TheEnd;
    }

    Size=IH->BytesLeftInChunk;
    if(!(ReadChunkData(IH, DTHDBuffer, IH->BytesLeftInChunk)==Size))
    {
     free((void *) DTHDBuffer);
     goto TheEnd;
    }

    DTH=(struct DataTypeHeader *) DTHDBuffer;

    DTH->dth_Name     = Swap32IfLE(DTH->dth_Name);
    DTH->dth_BaseName = Swap32IfLE(DTH->dth_BaseName);
    DTH->dth_Pattern  = Swap32IfLE(DTH->dth_Pattern);
    DTH->dth_Mask     = Swap32IfLE(DTH->dth_Mask);
    DTH->dth_GroupID  = Swap32IfLE(DTH->dth_GroupID);
    DTH->dth_ID       = Swap32IfLE(DTH->dth_ID);
    DTH->dth_MaskLen  = Swap16IfLE(DTH->dth_MaskLen);
    DTH->dth_Pad      = Swap16IfLE(DTH->dth_Pad);
    DTH->dth_Flags    = Swap16IfLE(DTH->dth_Flags);
    DTH->dth_Priority = Swap16IfLE(DTH->dth_Priority);

    fprintf(Out, "BaseName=%s\n", (char *) (((long) DTHDBuffer) + ((long) DTH->dth_BaseName)));

    fprintf(Out, "Pattern=%s\n", (char *) (((long) DTHDBuffer) + ((long) DTH->dth_Pattern)));

    fprintf(Out, "Mask=");
    for(i=1; i<=DTH->dth_MaskLen; i++)
    {
     fputc((int) *((char *) (((long) DTHDBuffer) + ((long) DTH->dth_Mask) + (2*i-1))), Out);
    }
    fprintf(Out, "\n");

    PrintID(DTH->dth_GroupID, ID);
    fprintf(Out, "GroupID=%s\n", ID);

    PrintID(DTH->dth_ID, ID);
    fprintf(Out, "ID=%s\n", ID);

    fprintf(Out, "Flags=");

    switch(DTH->dth_Flags&0x000F)
    {
     case 0:
     {
      fprintf(Out, "DTF_BINARY");

      break;
     }

     case 1:
     {
      fprintf(Out, "DTF_ASCII");

      break;
     }

     case 2:
     {
      fprintf(Out, "DTF_IFF");

      break;
     }

     case 3:
     {
      fprintf(Out, "DTF_MISC");

      break;
     }
    }

    if(DTH->dth_Flags & 0x0010)
    {
     fprintf(Out, ",DTF_CASE");
    }

    if(DTH->dth_Flags & 0x1000)
    {
     fprintf(Out, ",DTF_SYSTEM1");
    }

    fprintf(Out, "\n");

    fprintf(Out, "Priority=%hu\n", DTH->dth_Priority);

    free((void *) DTHDBuffer);
    SkipChunkData(IH);
    break;
   }

   default:
   {
    PrintID(IH->ChunkID, ID);
    fprintf(stderr, "Unsupported chunk : %s\n", ID);
    SkipChunkData(IH);
    break;
   }
  }
 }

TheEnd:

 CloseIFF(IH);
 if(TheOut)
 {
  fclose(TheOut);
 }
 return(0);
}

void PrintID(unsigned long ID, unsigned char *Buffer)
{
 if(!Buffer)
 {
  return;
 }

 Buffer[0]=(ID&0xFF000000)>>24;
 Buffer[1]=(ID&0xFF0000)  >>16;
 Buffer[2]=(ID&0xFF00)    >> 8;
 Buffer[3]=(ID&0xFF);
 Buffer[4]='\0';
}

